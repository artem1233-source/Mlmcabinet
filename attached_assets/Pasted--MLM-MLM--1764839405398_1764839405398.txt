Нужно исправить логику расчёта ранга пользователя в MLM-структуре.

Контекст:
– Это MLM-кабинет. У каждого пользователя есть дерево партнёров в глубину.
– В системе уже есть механика рангов, но сейчас она работает неверно.

Требования к правильному определению ранга:

1. Ранг пользователя = максимальная глубина его структуры ВНИЗ по дереву.
   – Сам пользователь не считается уровнем.
   – Если у пользователя нет ни одного партнёра под ним → ранг = 0.
   – Если есть только первая линия (но нет второй) → ранг = 1.
   – Если максимальная цепочка вглубь = N уровней → ранг = N.

   По сути:
   rank(user) = max(depth(descendant) – depth(user)), если потомков нет → 0.

2. Текущие проблемы:
   – Новые пользователи, у которых ещё нет подписанных партнёров, получают ранг 1.
   – Ожидаемое поведение: у них должен быть ранг 0 до момента, пока не появятся партнёры в глубину.

3. Что нужно сделать:

   3.1. Найти все места в проекте (frontend + supabase/server), где:
       – вычисляется или обновляется ранг пользователя;
       – используются поля с названиями типа "rank", "rang", "ранг", "maxDepth", "treeDepth";
       – ранги пересчитываются при:
         • регистрации нового пользователя;
         • изменении аплайна или структуры;
         • массовых перерасчётах дерева.

   3.2. Привести расчёт ранга к единой формуле:
       – вычислять глубину дерева относительно КОНКРЕТНОГО пользователя;
       – не включать самого пользователя в расчёт;
       – если глубина = 0 → ранг = 0.

       Если сейчас глубина считается как минимум 1, или берётся depthIncludingSelf,
       нужно скорректировать формулу:
       – либо вычитать 1,
       – либо изменить базовый случай рекурсии/DFS/BFS.

   3.3. Убедиться, что:
       – при регистрации нового пользователя ему сохраняется ранг 0;
       – при добавлении первого партнёра под ним ранг меняется на 1;
       – при углублении ветки на k уровней ранг корректно возрастает до k.

   3.4. Проверить, какие данные уже хранятся в базе:
       – поле ранга пользователя (название, тип);
       – есть ли отдельное кешированное поле глубины дерева.

       Ничего не мигрировать вручную, но:
       – добавить (или использовать уже существующий) административный скрипт/endpoint
         для полного перерасчёта рангов по всей структуре на основе актуального дерева.

   3.5. Обновить фронтенд-компоненты, если они завязаны на старую логику:
       – компонент, который рисует бейдж ранга (RankBadge или аналог);
       – дашборд, где отображается ранг пользователя;
       – фильтры/сортировки по рангу.
       UI-логика должна использовать одно и то же числовое поле ранга.

4. Тестирование (обязательно описать в конце, как запускать):

   – Написать или обновить минимальный набор тестов/скриптов:
     1) Пользователь A без партнёров → ранг 0.
     2) Пользователь A → подписан один партнёр B (без своей структуры) → ранг A = 1.
     3) A → B → C (цепочка в 2 уровня) → ранг A = 2, ранг B = 1, ранг C = 0.
     4) При удалении или переносе ветки ранги пересчитываются корректно вверх по дереву.

5. В конце:
   – Показать diff по всем изменённым файлам.
   – Кратко описать:
     • где именно была ошибка (off-by-one, включение самого пользователя и т.п.);
     • какая формула используется теперь;
     • как вручную запустить перерасчёт рангов для всех существующих пользователей.