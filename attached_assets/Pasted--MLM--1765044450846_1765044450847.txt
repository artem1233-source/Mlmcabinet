Нужно наконец синхронизировать математику MLM-комиссий с тем, как она реализована в форме редактирования товара в админке.

Главная идея:

Единственный источник истины — это ценовая лестница, задаваемая в форме товара (Component CommissionEditor / форма продукта):
«Розничная цена», «Цена уровня 1», «Цена уровня 2», «Цена уровня 3», «Цена компании».
Все комиссии L0–L3 должны вычисляться по тем же формулам, что и в этой форме. Backend не должен использовать свои внутренние хардкоды 1600/900/400/300 и т.п.

⸻

1. АУДИТ (без изменений кода)
	1.	Найди компонент/код, который отвечает за блок «Ценообразование / Комиссии» в форме товара (см. скриншоты с редактором товара):
	•	там есть поля: «Розничная цена», «Цена Уровень 1», «Цена Уровень 2», «Цена Уровень 3», «Цена компании»;
	•	справа в тех же карточках показываются «Доход L0, L1, L2, L3» и блоки «Розничная продажа» и «Партнёрская продажа» с формулами проверки.
	2.	В этом компоненте выяви точные формулы, которые сейчас используются для расчёта комиссий:
	•	как именно считаются L0, L1, L2, L3 из цен по уровням;
	•	какие именно поля (имена свойств) уходят в объект продукта при сохранении — разберись, что именно сохраняется в БД:
	•	сами цены по уровням;
	•	и/или уже посчитанный объект product.commission.
	3.	На backend:
	•	найди все места, где считаются или используются комиссии:
	•	calculatePayouts, convertToBackendFormat, BACKEND_DEFAULT_COMMISSIONS и т.п. (файл src/supabase/functions/server/commission_backend.ts и src/supabase/functions/server/index.tsx);
	•	выпиши:
	•	откуда сейчас берутся цифры для L0–L3 (из каких полей продукта или из каких дефолтов);
	•	в каких случаях backend использует BACKEND_DEFAULT_COMMISSIONS / старые d0/d1/d2/d3.

Сделай короткий отчёт в логах агента:
«Как сейчас считается в форме» vs «Как сейчас считает backend» и где именно несоответствие.

⸻

2. СИНХРОНИЗАЦИЯ ЛОГИКИ

После аудита нужно добиться, чтобы backend использовал именно те же формулы и те же данные, что и форма товара.

Бизнес-правило такое:
	•	В товаре задаются только ЦЕНЫ:
	•	P₀ — Розничная цена (гость)
	•	P₁ — Цена для партнёра 1 уровня
	•	P₂ — Цена для партнёра 2 уровня
	•	P₃ — Цена для партнёра 3 уровня
	•	P_company — Цена компании
	•	Комиссии всегда вычисляются из этих цен:
	•	L0 = P₀ − P₁
	•	L1 = P₁ − P₂
	•	L2 = P₂ − P₃
	•	L3 = P₃ − P_company
	•	Гостевая продажа (guest sale):
	•	гость платит P₀;
	•	L0 идёт продавцу;
	•	L1 идёт его спонсору (1-я линия), L2 — спонсору 2-й, L3 — спонсору 3-й;
	•	проверка: L0 + L1 + L2 + L3 + P_company = P₀.
	•	Партнёрская покупка (partner sale):
	•	партнёр платит P₁;
	•	L0 не участвует;
	•	L1 получает спонсор покупателя, L2 — его верхний, L3 — следующий;
	•	проверка: L1 + L2 + L3 + P_company = P₁.
	•	Эти правила одинаковы для любого товара; отличаются только сами цены.

Задача: backend должен опираться на те же поля товара (P₀ … P_company) и на эти формулы, а не на свои внутренние таблицы.

Конкретные шаги:
	1.	В commission_backend.ts:
	•	добавь/исправь функцию, которая:
	•	читает из объекта product ценовую лестницу, которую сохраняет форма (определи имена полей по коду формы);
	•	по этим значениям пересчитывает L0–L3 ровно по тем же формулам, что в CommissionEditor;
	•	возвращает объект комиссий для гостевой продажи и для партнёрской (guest vs partner) — причём L1/L2/L3 должны быть одинаковыми в обоих случаях, отличаться должен только факт, участвует ли L0.
	•	BACKEND_DEFAULT_COMMISSIONS и старые d0/d1/d2/d3 оставь только как аварийный fallback, если у товара вообще нет данных (для наших реальных SKU это использоваться не должно).
	2.	В calculatePayouts:
	•	убери прямую зависимость от дефолтов и старых структур;
	•	используй только функцию из пункта 1 для получения комиссий на основе данных товара;
	•	для гостевой продажи (isPartner=false) учитывай L0+L1+L2+L3; для партнёрской (isPartner=true) — только L1/L2/L3, с теми же значениями, что и в гостевой формуле.
	3.	Убедись, что все потоки заказа (guest sale, обычная покупка партнёра, корзина, demo-payment, YooKassa webhook) проходят через:
	•	поиск товара по sku;
	•	вычисление комиссий через новую функцию (из цен по уровням);
	•	сохранение этих комиссий в заказ;
	•	создание earnings из заказа без повторного ручного пересчёта.

⸻

3. ЛОГИ ДЛЯ ПРОВЕРКИ

Добавь подробные логи (console.log) в месте, где уже есть рассчитанные комиссии и создаются earnings, например в createEarningsFromOrder:
	•	SKU товара;
	•	флаг isPartner;
	•	считанные цены P₀, P₁, P₂, P₃, P_company;
	•	рассчитанные L0–L3;
	•	список earnings по userId/level/amount.

Я должен по логам видеть, что при покупке реального товара используются именно те P₀…P_company, которые я задал в форме товара, и что все L-комиссии совпадают с тем, что отображается в форме.

⸻

4. КОРОТКАЯ ИНСТРУКЦИЯ ДЛЯ ТЕСТА

В конце напиши в отчёте:
	•	какие поля товара backend теперь использует (конкретные имена свойств);
	•	какие формулы он применяет;
	•	как мне воспроизвести тест:
	1.	создать товар с произвольной лестницей цен;
	2.	сделать гостевую продажу;
	3.	сделать партнёрскую продажу;
	4.	где в логах посмотреть подтверждение, что суммы для L0–L3 совпали с тем, что показывает форма товара.

Важно: никакие старые жёсткие числа (1600/900/400/300) не должны участвовать в расчётах, если у товара заданы свои цены.