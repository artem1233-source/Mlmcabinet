Наша цель — целиком привести в порядок комиссионную математику MLM для ВСЕХ типов покупок, а не только «Продать гостю».

Хочу, чтобы:
	1.	Единый источник правды по комиссиям был:
	•	product.commission (структура ProductCommission),
	•		•	логика calcOrder / convertToBackendFormat / calculatePayouts.
	2.	Все типы покупок (как минимум):
	•	покупка партнёром для себя (обычная «Купить»),
	•	«Продать гостю» из каталога,
	•	покупка через корзину/Checkout,
	•	демо-покупки (если они завязаны на те же комиссии),
— использовали одну и ту же MLM-логику расчёта payouts и начисления earnings.
	3.	Для любой покупки:
	•	правильно считается цепочка upline (u0 — сам, u1, u2, u3…),
	•	правильно расставляются L0/L1/L2/L3 (или выше, если есть),
	•	создаются earnings для каждого участника,
	•	и это корректно отображается:
	•	в разделе «Доходы»,
	•	в балансе,
	•	в дашбордах.

Сейчас ситуация такая:
	•	ранги мы уже починили, всё ок — прошу не трогать систему рангов;
	•	комиссии частично работают, частично нет:
	•	«Продать гостю» иногда даёт доход только продавцу;
	•	у вышестоящих пользователей в «Доходах» пусто;
	•	логика guest/partner может отличаться между фронтом и бэком;
	•	уже были попытки править calculatePayouts, commission_backend.ts, earnings, но итог до конца не доведён.

Мне нужен последовательный debug и доведение до рабочего состояния всей цепочки MLM-комиссий, без побочных поломок.

⸻

ШАГ 0. Ограничения и рамки
	1.	Не трогать:
	•	ранги и всё, что связано с rank / уровень / rank_calculator,
	•	дерево структуры, визуализации дерева,
	•	систему ID, смену ID и т.п.
	2.	Можно трогать:
	•	src/utils/types/commission.ts,
	•	src/utils/mlm.ts,
	•	src/supabase/functions/server/commission_backend.ts,
	•	src/supabase/functions/server/index.tsx (только разделы про заказы и earnings),
	•	фронтенд-компоненты:
	•	CatalogRu.tsx,
	•	CartRu.tsx,
	•	CheckoutRu.tsx,
	•	GuestSaleModal.tsx,
	•	EarningsRu.tsx,
	•	BalanceRu.tsx,
	•	дашборды по доходам, если там есть отдельная логика.
	3.	Пожалуйста, делай минимально необходимый объём изменений и:
	•	всегда сначала анализируй,
	•	потом проверяй на одном конкретном сценарии покупки, и только после этого фиксируй код.

⸻

ШАГ 1. КАРТА ВСЕХ ПОТОКОВ ПОКУПКИ
	1.	Найди и выпиши все места во фронтенде, откуда уходит создание заказа:
	•	покупка партнёром для себя (кнопка «Купить»),
	•	продажа гостю («Продать гостю»),
	•	покупки через корзину/Checkout,
	•	демо/тестовые покупки (если влияют на реальные комиссии).
	2.	Для каждого из этих потоков:
	•	найди, какой метод api.* вызывается (createOrder, checkout, и т.д.),
	•	найди на бэкенде соответствующий endpoint в index.tsx,
	•	убедись, что любой реальный платёж в итоге проходит через:
	•	создание order,
	•	и затем подтверждение order:
	•	/orders/:orderId/confirm,
	•	или webhook платёжки,
	•	или демо-confirm.
	3.	Составь себе (и в replit.md) небольшую схему типа:
	•	«Купить» партнёром → CatalogRu → api.createOrder(..., isPartner=true) → POST /orders → оплата → POST /orders/:orderId/confirm.
	•	«Продать гостю» → GuestSaleModal → api.createOrder(..., isPartner=false) → … → confirm.
	•	Корзина → CartRu / CheckoutRu → ….
	4.	Наша цель — любое место, где платёж считается “прошедшим”, обязано идти через один и тот же механизм начисления MLM-комиссий.

⸻

ШАГ 2. ЕДИНАЯ ФУНКЦИЯ РАСЧЁТА КОМИССИЙ
	1.	Проверь src/utils/types/commission.ts и src/utils/mlm.ts:
	•	структура ProductCommission (guest/partner, L0–L3),
	•	DEFAULT_COMMISSIONS,
	•	getProductCommissions(product),
	•	calcOrder(...) — фронтовая эталонная логика.
	2.	Проверь src/supabase/functions/server/commission_backend.ts:
	•	convertToBackendFormat(product, isPartner),
	•	getProductPrices(product),
	•	BACKEND_DEFAULT_COMMISSIONS, BACKEND_DEFAULT_PRICES.
	3.	Проверь в index.tsx:
	•	calculatePayouts(price, isPartner, sku, upline).
	4.	Требование:
	•	логика calculatePayouts на бэкенде должна быть полностью согласована с фронтовой calcOrder / ProductCommission:
	•	для покупки партнёром (isPartner=true) использовать ветку commission.partner,
	•	для гостя (isPartner=false) — commission.guest,
	•	распределить d0/d1/d2/d3 по u0/u1/u2/u3.
	5.	Сделай минимальные правки, чтобы:
	•	никакие 1600/900/500/200 и т.п. не были хардкожены внутри index.tsx,
	•	все суммы комиссий брались из:
	•	product.commission (если задано),
	•	или DEFAULT_COMMISSIONS / BACKEND_DEFAULT_COMMISSIONS как fallback.
	6.	Добавь подсказочные логи в calculatePayouts:
	•	sku, isPartner, uplineIds, commissions, payouts.

⸻

ШАГ 3. ЕДИНАЯ СХЕМА ПОХОЖДЕНИЯ Payouts → Order → Earnings
	1.	Найди в index.tsx:
	•	где создаётся order при любом типе покупки,
	•	где в order кладутся:
	•	комиссии (mapping userId → сумма),
	•	комиссииУровни (userId → ‘L0’/‘L1’/‘L2’/‘L3’),
	•	(возможно, платежи / payouts).
	2.	Требование:
	•	для каждого элемента payouts ({ userId, amount, level }) из calculatePayouts:
	•	обязательно:
	•	order.комиссии[userId] = amount,
	•	order.комиссииУровни[userId] = 'L0'|'L1'|'L2'|'L3' (строка).
	3.	Убедись, что это выполняется:
	•	при создании заказа для гостя,
	•	при создании заказа для партнёра,
	•	при покупках через корзину.
	4.	Затем найди ВСЕ места создания earnings:
	•	/orders/:orderId/confirm,
	•	demo-оплата,
	•	webhook YooKassa (если нужен).
	5.	Здесь нужна единая функция-помощник, например:
	•	createEarningsFromOrder(order),
	•	которая:
	•	итерирует Object.entries(order.комиссии),
	•	для каждого userId создаёт запись earning:
	•	userId,
	•	amount,
	•	level (строка ‘L0’…),
	•	линия (число 0…),
	•	sku,
	•	isPartner и т.п.
	•	сохраняет их в KV вида earning:user:${userId}:....
	6.	Затем:
	•	вытащи дублирующий код из confirm/demo/webhook в этот helper,
	•	в каждом месте подтверждения платежа просто вызывай helper.
	7.	Добавь лог в helper:
	•	order.id,
	•	список {userId, amount, level, линия}.

⸻

ШАГ 4. ПРОВЕРКА КОНКРЕТНЫХ СЦЕНАРИЕВ

Сценарий А: покупка партнёром для себя
	1.	Возьми цепочку пользователей с понятной структурой (например, U0 с аплайнами U1, U2, U3).
	2.	Пускай U0 купит продукт как партнёр:
	•	кнопка «Купить»,
	•	isPartner=true.
	3.	Проверь по логам:
	•	calculatePayouts → payouts корректны,
	•	order.комиссии и order.комиссииУровни содержат U0/U1/U2/U3,
	•	helper по earnings создал записи для всех этих userId.
	4.	Проверь в UI:
	•	у U0 в «Доходах» есть L0,
	•	у U1 — L1,
	•	у U2 — L2,
	•	у U3 — L3.

⸻

Сценарий B: «Продать гостю»
	1.	Тот же набор пользователей.
	2.	Продажа через GuestSaleModal / «Продать гостю»:
	•	isPartner=false.
	3.	Повтори ту же проверку:
	•	payouts,
	•	order.комиссии,
	•	earnings,
	•	UI для U0, U1, U2, U3.

⸻

Сценарий C: покупка через корзину/Checkout
	1.	Возьми того же U0.
	2.	Соверши покупку через Cart/Checkout.
	3.	Проверь:
	•	что цепочка обработана тем же кодом:
	•	calculatePayouts,
	•	order.комиссии,
	•	createEarningsFromOrder.
	4.	Убедись, что после этих правок все три сценария дают одинаково корректное распределение комиссий (разница только в ветке гостя/партнёра).

⸻

ШАГ 5. ФРОНТЕНД ОТОБРАЖЕНИЯ ДОХОДОВ
	1.	Проверь EarningsRu.tsx:
	•	что он корректно читает как старый формат (линия), так и новый (level = 'L0'...'L3'),
	•	и нормализует их в одно значение уровня (например, lineIndex).
	2.	Проверь BalanceRu, дашборды, если они:
	•	апеллируют к earnings напрямую,
	•	не делают там «самодельную» математику, отличную от earnings.
	3.	Наша цель: после того, как бэкенд создаёт правильные earnings, UI просто честно их показывает, без дополнительной логики перерасчёта.

⸻

ШАГ 6. ФИНАЛЬНЫЙ ОТЧЁТ

В конце работы:
	1.	Дай краткий, но конкретный отчёт:
	•	какие файлы были изменены,
	•	какой общий путь теперь у комиссий:
	•	product.commission → calculatePayouts / convertToBackendFormat → order.комиссии → createEarningsFromOrder → earnings → EarningsRu/Balances.
	2.	Обязательно укажи:
	•	на каком реальном тесте (цепочка U0–U3, покупка как партнёр, «Продать гостю», покупка через корзину) ты проверил, что:
	•	суммы L0/L1/L2/L3 соответствуют настройкам товара,
	•	доход виден у всех участников структуры.
