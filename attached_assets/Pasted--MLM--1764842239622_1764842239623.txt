Нужно исправить расчёт и отображение рангов в MLM-дереве.

Бизнес-правило ранга:
	•	Ранг пользователя = длина самой глубокой ветки под ним (глубина структуры вниз).
	•	Если под пользователем нет ни одного партнёра, его ранг 0.
	•	Если под ним цепочка длиной 1 уровень → ранг 1, длиной 2 → ранг 2 и т.д.
	•	Сам пользователь не считается уровнем (то есть «нет команды» = ранг 0, а не 1).

На бэкенде логика уже реализована в src/supabase/functions/server/rank_calculator.tsx
(функции calculateTreeDepth, getUserRank, эндпоинты diagnose-ranks, recalculate-all-ranks).

Симптом сейчас:
	•	Новый пользователь, только что зарегистрированный и без команды, во фронтенде в дереве отображается как Ранг 1, хотя должен быть Ранг 0.
	•	Похоже, сначала показывается правильное значение, а потом какой-то клиентский код пересчитывает/перезаписывает ранг и он становится неправильным.

Что нужно сделать:
	1.	Найти все места во фронтенде, где рассчитывается или отображается ранг:
	•	компоненты дерева: UsersTreeView.tsx, UsersTreeRenderer.tsx, Structure.tsx, StructureDataViz.tsx (и другие, если есть);
	•	компонент, который рисует бейдж ранга (RankBadge.tsx или аналог);
	•	любые хелперы, где есть слова rank, ранг, уровень, depth, maxDepth.
	2.	Для каждого найденного места:
	•	Проверить, откуда берётся значение ранга:
	•	из API / KV (getUserRank, поле пользователя rank, ранг);
	•	или вычисляется на клиенте по depth, уровень, позиции в дереве и т.д.
	•	Удалить или отключить всю клиентскую логику пересчёта ранга, которая делает что-то вроде:
	•	rank = depth + 1,
	•	rank = maxDepth - depth,
	•	node.ранг = ... на фронте.
	•	Сделать так, чтобы компонент дерева и бейдж ранга использовали только:
	•	либо поле ранга, которое приходит из API (если уже есть),
	•	либо результат вызова соответствующего backend-эндпоинта, если это уже сделано в текущем коде.
	3.	Проверить, нет ли путаницы между:
	•	user.уровень (позиция в дереве относительно корня)
	•	и рангом, который считается по глубине его собственной ветки.
Если во фронтенде где-то присваивается ранг = user.уровень или производная от него — это нужно заменить на использование настоящего ранга, приходящего с бэкенда.
	4.	Убедиться, что:
	•	при первой загрузке дерева ранг не пересчитывается на клиенте по depth или размеру команды;
	•	никакие useEffect / map() при построении дерева не мутируют поле ранга в узлах.
	5.	Добавить минимальную защиту от офф-бай-ван:
	•	если у узла нет детей (children.length === 0 или пустой список) — во фронтенде он всегда должен отображаться как ранг 0;
	•	проверить, что при любом варианте сериализации/мэппинга дерева ранг не становится 1 в этом случае.
	6.	В конце:
	•	Показать diff по всем изменённым frontend-файлам, особенно компонентам дерева и ранга;
	•	Кратко описать:
	•	откуда теперь берётся значение ранга;
	•	какую клиентскую математику по рангу ты удалил;
	•	как теперь гарантируется, что новый пользователь без команды имеет ранг 0 и этот ранг не «подскакивает» после перерисовки дерева.

Важно: не менять саму backend-логику рангов в rank_calculator.tsx (она уже настроена), правим только фронтенд-отображение и возможные клиентские пересчёты.