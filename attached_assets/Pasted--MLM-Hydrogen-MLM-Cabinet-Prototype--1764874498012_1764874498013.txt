Мы работаем над проектом MLM-кабинета (Hydrogen MLM Cabinet Prototype).
Твоя задача сейчас — не рефакторить ради красоты, а довести до ума всю математику MLM-комиссий и начисления доходов для ВСЕХ типов покупок, а не только «Продать гостю».

0. ВАЖНО: что считать правильным результатом

Бизнес-логика комиссий:
	1.	Есть товар с полем commission/комиссии, в котором заданы выплаты по уровням.
	2.	Структура MLM строится по полю спонсорId (upline-цепочка).
	3.	Типы продаж:
	•	Гостевая продажа через партнёра (кнопка «Продать гостю»):
	•	L0 = комиссия продавца (тот, кто нажал «Продать гостю»).
	•	L1, L2, L3 = его спонсоры вверх по цепочке.
	•	Партнёрская покупка (кнопка «Купить» для авторизованного партнёра):
	•	у покупателя L0 не должно начисляться (он уже взял партнёрскую цену),
	•	L1, L2, L3 = спонсоры покупателя.
	•	Покупка через корзину (Cart + Checkout): та же логика, что и для «Купить».
	4.	Для любой покупки, если хватает глубины структуры, должны быть записаны earning-записи:
	•	у каждого пользователя, который должен получить комиссию;
	•	с корректными полями:
	•	userId — кому платим,
	•	orderId,
	•	amount (сумма),
	•	level (строка 'L0' | 'L1' | 'L2' | 'L3'),
	•	линия (число 0 / 1 / 2 / 3, синхронизированное с level),
	•	fromUserId (кто инициировал покупку, либо сам покупатель, либо продавец при гостевой продажe),
	•	sku, isPartner, createdAt.

Цель: после твоих правок я должен увидеть в интерфейсе:
	•	у продавца — доход по L0,
	•	у его аплайнов — L1/L2/L3,
	•	и то же самое для партнёрской покупки: комиссия у аплайнов покупателя.

Сейчас этого нет: часть сценариев не даёт начислений, часть даёт только L0, часть вообще не отражается во «Доходах».

⸻

1. Сначала — полный аудит БЕЗ изменений
	1.	Найди все места в коде, где:
	•	создаются orders;
	•	вызывается calculatePayouts;
	•	создаются earnings.
	2.	Особое внимание к файлам:
	•	src/supabase/functions/server/index.tsx
	•	src/supabase/functions/server/commission_backend.ts
	•	src/components/CatalogRu.tsx
	•	src/components/GuestSaleModal.tsx
	•	src/components/CheckoutRu.tsx
	•	src/components/CartRu.tsx
	•	src/utils/api.ts
	•	src/components/EarningsRu.tsx
	•	src/components/BalanceRu.tsx
	3.	Сделай короткий отчёт (как ты уже умеешь):
	•	какие потоки покупок есть (гость, партнёр, корзина, демо-оплата, YooKassa);
	•	в какой момент реально создаются earnings;
	•	какие поля у earnings фактически сохраняются (прямо покажи структуру объекта, которую кладёшь в KV).

На этом шаге код НЕ менять. Только анализ.

⸻

2. Привести всё к одному источнику правды для комиссий

Дальше — аккуратные изменения.
	1.	Убедись, что все вычисления комиссий на backend используют:
	•	product.commission / product.комиссии
	•	через convertToBackendFormat(...) и/или calculatePayouts(...)
	•	без локальных хардкодов цифр 1600 / 900 / 500 / 200 и т.п.
	2.	Проверь, что для всех потоков:
	•	Guest sale (продажа гостю);
	•	Partner buy (партнёр покупает себе);
	•	Cart buy (покупка через корзину);
	•	Demo payment;
	•	YooKassa webhook;
используется один и тот же путь:
	1.	есть order с полями sku, продавецId / покупательId, и рассчитанными комиссиями (order.комиссии, order.комиссииУровни или аналог);
	2.	затем вызывается одна helper-функция (например, createEarningsFromOrder(order)), которая:
	•	берёт order.комиссии / order.платежи / что там сейчас в новом формате;
	•	и создаёт earnings в KV.

Если где-то поток идёт «в обход» этой функции — приведи его к одному стандарту.

⸻

3. Привести earnings к единому формату

Сейчас явная проблема: в одних местах есть level = 'L0', в других — только линия, в третьих — вообще только суммы.

Сделай так:
	1.	Во всех кодовых местах, где создаются earnings:
	•	вычисляй lineIndex:
	•	если есть level вида 'L0', 'L1' и т.п. → извлекай число из строки;
	•	если есть только линия (старый формат) → используй как есть;
	•	всегда записывай:
	•	amount,
	•	level (строка),
	•	линия (число),
	•	sku,
	•	isPartner,
	•	fromUserId.
	2.	Обеспечь обратную совместимость:
	•	старые записи в KV, где нет части полей, должны по-прежнему корректно обрабатываться фронтендом.

⸻

4. Отображение на фронтенде (EarningsRu / BalanceRu)

Убедись, что:
	1.	EarningsRu.tsx:
	•	берёт данные из API;
	•	правильно определяет уровень:
	•	если есть e.level — использовать его;
	•	если нет, но есть e.линия — сконструировать L${e.линия};
	•	корректно группирует по датам и уровням.
	2.	BalanceRu.tsx:
	•	считает общий доход как сумму amount/сумма из всех earning.
	3.	Если где-то фронтенд до сих пор ожидает старые поля (например, e.линия без level) — добавь аккуратный fallback, не ломая новый формат.

⸻

5. ОБЯЗАТЕЛЬНО: Автотест MLM-математики

Очень важно не просто «поверить на слово», а протестировать в коде.

Сделай, пожалуйста, простой тестовый эндпоинт или сценарий (например, /admin/debug-mlm-test), который:
	1.	Создаёт тестовую структуру в KV (временных пользователей), например:
	•	U001 — верхний спонсор (root),
	•	U002 — его первая линия (спонсорId = U001),
	•	U003 — вторая линия (спонсорId = U002),
	•	U004 — третья линия (спонсорId = U003).
	2.	Создаёт тестовый товар H2-TEST с понятными комиссиями:
	•	L0 = 1000
	•	L1 = 500
	•	L2 = 300
	•	L3 = 100
	3.	Прогоняет три сценария (можно прямо внутри handler’а, без UI):
	•	Сценарий A — „Продать гостю“
	•	Продавец: U004
	•	Ожидаем:
	•	earnings на U004 → 1000 (L0)
	•	на U003 → 500 (L1)
	•	на U002 → 300 (L2)
	•	на U001 → 100 (L3)
	•	Сценарий B — партнёрская покупка
	•	Покупатель: U004 (сам покупает как партнёр)
	•	Ожидаем:
	•	U004 НЕ получает L0 вообще;
	•	U003, U002, U001 получают L1/L2/L3 как в правилах.
	•	Сценарий C — покупка через корзину
	•	Аналогично B, но через путь Cart + Checkout.
	4.	В ответе этого тестового эндпоинта в явном виде выведи:
	•	список созданных orders;
	•	список созданных earnings по каждому userId;
	•	и отдельно — расхождения «ожидалось / фактически».

Важно: если какой-то из сценариев даёт не то, что ожидается — не маскируй это, а явно распиши в логах и исправь код до тех пор, пока тест не станет зелёным.

⸻

6. После изменений
	1.	Обнови replit.md с:
	•	краткой схемой всех потоков (Guest sale / Partner buy / Cart / Demo / YooKassa);
	•	описанием createEarningsFromOrder(order) (если ты её оставляешь как центр);
	•	описанием тестового эндпоинта /admin/debug-mlm-test и как им пользоваться.
	2.	Проверь вручную через UI:
	•	гостевая продажа через «Продать гостю»;
	•	покупка партнёром через «Купить»;
	•	покупка через корзину.
Для каждой — проверь раздел «Доходы» у:
	•	продавца/покупателя,
	•	первой, второй, третьей линии выше.

Пока математика и отображение не совпадают с бизнес-правилом, считаем задачу НЕ выполненной. Делай изменения итеративно и обязательно опирайся на тестовый сценарий (пункт 5).