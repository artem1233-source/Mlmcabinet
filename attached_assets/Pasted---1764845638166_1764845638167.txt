Мне нужно найти, почему ранги пользователей в структуре показываются неправильно, хотя логика на бэкенде уже приведена к формуле:

• нет детей → ранг = 0
• есть дети → ранг = max(ранг детей) + 1

Примеры цепочки: A → B → C → D → E
• E = 0, C = 2, A = 4 и т.д.

Важно: на этом шаге НЕЛЬЗЯ вносить изменения в код. Только анализ и отчёт.

1. Пройди путь «ранга» на бэкенде
	1.	Найди все места на сервере, которые:
	•	считают ранг
	•	сохраняют его
	•	кешируют его
	•	отдают наружу через API.
Ожидаемые файлы/места:
	•	src/supabase/functions/server/rank_calculator.tsx
	•	src/supabase/functions/server/user_metrics_cache.tsx
	•	src/supabase/functions/server/index.tsx (эндпоинты /user/:id/rank, /admin/diagnose-ranks, /admin/recalculate-all-ranks, регистрация и т.д.)
	2.	Для конкретного набора пользователей (возьми любых 5–7 пользователей из текущей базы: например, тех, у кого id: 001, 002, 003, 004, 005, 007 — если они есть):
	•	определи их фактическую структуру (кто чей аплайн / дети) по данным в KV/БД (upline, команда и т.п.);
	•	посчитай ожидаемый ранг по формуле (max глубина вниз);
	•	посмотри, какие значения:
	•	лежат в user.уровень
	•	лежат в KV-кеше rank:user:{userId}
	•	лежат в user_metrics:{userId} (если там есть rank)
	•	возвращают эндпоинты:
	•	/user/:id/rank
	•	/admin/diagnose-ranks (если есть)
В отчёте нужно по каждому такому пользователю сделать таблицу:
	•	userId
	•	структура (кто под ним)
	•	ожидаемый ранг (по формуле)
	•	user.уровень
	•	KV rank:user:{id}
	•	rank в user_metrics (если есть)
	•	что возвращает API.
	3.	Отдельно проверь, что именно делает кнопка «Пересчитать ранги» на сервере:
	•	какой эндпоинт она вызывает;
	•	как внутри пересчитываются ранги;
	•	какие поля/кеши обновляются, а какие — нет.

2. Пройди путь «ранга» на фронтенде

Нужно понять, откуда берётся то число, которое я вижу в админской структуре и в личном кабинете пользователя.
	1.	Для экрана админ-дерева структуры:
	•	найди компонент(ы), которые рисуют список/дерево партнёров (например, UserTreeRenderer, VirtualizedTreeView, UsersManagementOptimized, StructureDataViz и пр.);
	•	определи:
	•	откуда в них приходит ранг (какой хук / API / контекст);
	•	какое именно поле используется (user.уровень, user.rank, metrics.rank, userRanks Map и т.д.);
	•	нет ли нигде дополнительных перерасчётов или модификаций ранга на клиенте (дополнительные функции, пересчёт по дереву, Math.max и т.п.).
	2.	Для личного кабинета пользователя:
	•	найди компонент, который показывает ранг текущему пользователю (Dashboard, Profile и т.д.);
	•	так же зафиксируй:
	•	откуда читается ранг;
	•	какие fallback-значения используются (|| 1, ?? 0 и т.п.);
	•	нет ли отличий от админки.
	3.	Отдельно перечисли все места на фронтенде, где:
	•	есть fallback вида уровень || 1 или любое другое выражение, которое запрещает показывать 0;
	•	ранги пересчитываются по дереву на клиенте (функции вида calculateRankFromTree, любые локальные алгоритмы).

3. Итоговый отчёт

В конце сделай компактное резюме:
	1.	Есть ли расхождение между:
	•	ожидаемым рангом по формуле;
	•	тем, что хранится в БД/кеше;
	•	тем, что отдаёт API;
	•	тем, что показывает фронт.
	2.	Где именно (в каких файлах / функциях) происходит «загрязнение» ранга:
	•	неверное сохранение на сервере;
	•	старый кеш, который не сбрасывается;
	•	перерасчёт и подмена на фронтенде;
	•	принудительная замена 0 → 1 и т.п.
	3.	Никаких изменений кода на этом шаге не делай. Только анализ и подробный отчёт с указанием строк и файлов, которые, по твоему мнению, нужно будет менять на следующем шаге.